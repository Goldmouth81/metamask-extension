import yargs from 'yargs/yargs';
import { Browser, Browsers, Manifest } from './helpers';

const { loadBuildTypesConfig } = require('../development/lib/build-type') as {
  loadBuildTypesConfig: () => {
    features: { [x: string]: unknown };
    buildTypes: { [x: string]: { features: string[] } };
  };
};

/**
 * Yargs doesn't support comma-separated arrays, like `myprogram --multi one,two,three --multi four`.
 * This function gives us the ability to "coerce" the CSV string into an array
 *
 * Note: CSV parsing is a naive string-split-on-comma approach.
 *
 * @param array
 * @returns
 */
function parseArrayOptionAsCsv<T extends string = string>(
  array: string[],
): T[] {
  return array.flatMap<T>((v) => v.split(',') as T[]);
}

/**
 * Parses `argv` into a more usable format.
 *
 * @param argv - The arguments to parse.
 * @returns An object containing the parsed arguments.
 */
export const parseArgv = (argv: string[]) => {
  const { features, buildTypes } = loadBuildTypesConfig();
  const allFeatures = Object.keys(features);

  // clean up the output a bit and build the list of features
  const cli = generateCli(argv, Object.keys(buildTypes), allFeatures);
  const { $0, _, include, i, exclude, e, ...options } = cli.parseSync();

  const defaults = buildTypes[options.type]?.features || [];
  const excludeSet = new Set(exclude);
  const active = new Set<string>();
  const all = new Set(allFeatures);
  for (const item of defaults) {
    excludeSet.has(item) || active.add(item);
  }
  for (const item of include) {
    excludeSet.has(item) || active.add(item);
  }

  return {
    options,
    features: {
      active,
      all,
    },
  };
};

/**
 * Generates a yargs instance for parsing CLI arguments.
 *
 * @param argv
 * @param buildTypes
 * @param allFeatures
 */
export function generateCli(
  argv: string[],
  buildTypes: string[],
  allFeatures: string[],
) {
  const modeOptions = {
    group: 'Build options:',
    alias: 'm',
    description:
      'Enables/disables production optimizations or development hints.',
    default: 'development' as const,
    choices: ['development', 'production'] as const,
  };

  let _isProduction: boolean; // for memoization
  /**
   * Peek at the `mode` option to determine if we're in production mode.
   *
   * @returns `true` if mode is production, otherwise `false`
   */
  function peekIsProduction(): boolean {
    if (typeof _isProduction !== 'undefined') {
      return _isProduction;
    }

    const { mode } = yargs(argv)
      .help(false)
      .version(false)
      .showHelpOnFail(false)
      .option('mode', modeOptions)
      .parseSync();
    return (_isProduction = mode === 'production');
  }

  const cli = yargs(argv)
    // Ensure unrecognized commands/options are reported as errors.
    .strict()
    // wrap output at a maximum of 120 characters or `process.stdout.columns`
    .wrap(Math.min(120, process.stdout.columns))
    // enable the `completion` command, which outputs a bash completion script
    .completion(
      'completion',
      'To enable bash/zsh completions, concat the script generated by running this command to your .bashrc or .bash_profile (or .zshrc for zsh).',
    )
    // enable the --config command, which allows the user to specify a custom
    // config file containing webpack options
    .config()
    // enable ENV parsing, which allows the user to specify webpack options via
    // environment variables prefixed with `MM_`
    .env('BUNDLE')
    // use the scriptName in --help output
    .scriptName('yarn webpack')
    .example(
      '$0 --mode development --browser brave --browser chrome --zip',
      'Builds the extension in dev mode for Chrome & Brave; generates zip files for both.',
    )
    .example(
      '$0 completion',
      'Generates a bash completion script for the `yarn webpack` command.',
    )

    .option('mode', modeOptions)
    .option('watch', {
      group: 'Developer assistance:',
      alias: 'w',
      description: 'Run build and watch for files changes.',
      type: 'boolean',
      default: false,
    })
    .option('cache', {
      group: 'Developer assistance:',
      alias: 'c',
      description: 'Cache changes for faster rebuilds.',
      type: 'boolean',
      default: true,
    })
    .option('progress', {
      group: 'Developer assistance:',
      alias: 'p',
      description: 'Show build progress.',
      type: 'boolean',
      default: true,
    })
    .option('devtool', {
      group: 'Developer assistance:',
      alias: 'd',
      description: 'Sourcemap type to generate.',
      defaultDescription:
        'When mode is `production`, `hidden-source-map`, otherwise `source-map`.',
      // yargs types are broken; it thinks `default` returns a function if it _is_ a function (but yargs actually just calls it)
      default: (() => {
        return peekIsProduction() ? 'hidden-source-map' : 'source-map';
      }) as unknown as 'none' | 'source-map' | 'hidden-source-map',
      choices: ['none', 'source-map', 'hidden-source-map'] as const,
    })
    .option('zip', {
      group: 'Build options:',
      alias: 'z',
      description: 'Generate a zip file of the build.',
      type: 'boolean',
      default: false,
    })
    .option('minify', {
      group: 'Build options:',
      alias: 'mi',
      description: 'Minify the output.',
      type: 'boolean',
      default: false,
    })
    .option('browser', {
      group: 'Build options:',
      alias: 'b',
      description: 'Browsers to build for.',
      type: 'string',
      default: 'chrome',
      array: true,
      choices: Browsers,
      coerce: (array: string[]) => parseArrayOptionAsCsv<Browser>(array),
    })
    .option('manifest_version', {
      group: 'Build options:',
      alias: 'mv',
      description: 'Manifest version to build for.',
      type: 'number',
      default: 2 as Manifest['manifest_version'],
      choices: [2, 3] as Manifest['manifest_version'][],
    })
    .option('type', {
      group: 'Build options:',
      alias: 't',
      description:
        'Enables/disables feature flags based on the given type (main, beta, flask, etc).',
      type: 'string',
      default: 'main' as const,
      choices: ['none', ...buildTypes],
    })
    .option('include', {
      group: 'Build options:',
      alias: 'i',
      description:
        'Features you want enabled that are not already included in the selected build type.',
      array: true,
      type: 'string',
      default: [] as typeof allFeatures,
      choices: allFeatures,
      coerce: parseArrayOptionAsCsv,
    })
    .option('exclude', {
      group: 'Build options:',
      alias: 'e',
      description:
        'Features you want disabled that are already included in the selected build type.',
      array: true,
      type: 'string',
      default: [] as typeof allFeatures,
      choices: allFeatures,
      coerce: parseArrayOptionAsCsv,
    })
    .option('lavamoat', {
      group: 'Security:',
      alias: 'l',
      description: 'Apply lavamoat to the build assets.',
      defaultDescription:
        'When mode is `production`, `true`, otherwise `false`.',
      type: 'boolean',
      // yargs types are broken; it thinks `default` returns a function if it _is_ a function (but yargs actually just calls it)
      default: peekIsProduction as unknown as boolean,
    })
    .option('snow', {
      group: 'Security:',
      alias: 's',
      description: 'Apply Snow to the build assets.',
      defaultDescription:
        'When mode is `production`, `true`, otherwise `false`.',
      type: 'boolean',
      // yargs types are broken; it thinks `default` returns a function if it _is_ a function (but yargs actually just calls it)
      default: peekIsProduction as unknown as boolean,
    });

  return cli;
}
